import { keyboards } from './data/keyboards.js';
import { RandomChars } from './utils/random-char.js';
import { Resetter } from './utils/resetter.js';
import { isSpecialChar } from './utils/is-special-char.js';
import { wait } from './utils/wait.js';
import { Queue } from './types/queue.js';
export class Typed {
    constructor(options) {
        this._resetter = new Resetter();
        this._randomChars = new RandomChars();
        this._typeQueue = new Queue(this._resetter);
        this._ffQueue = new Queue(this._resetter);
        this._queue = this._typeQueue;
        this._resultItems = [];
        this._fastForward = false;
        this._lettersSinceLastError = 0;
        this._endResultItems = [];
        this._fastForwardOptions = {
            perLetterDelay: { min: 10, max: 20 },
            eraseDelay: { min: 10, max: 20 },
            errorDelay: { min: 100, max: 200 }
        };
        this._options = options;
    }
    get options() {
        var _a, _b;
        const defaultOptions = {
            callback: () => {
                // do nothing
            },
            eraseDelay: { min: 150, max: 250 },
            errorDelay: { min: 50, max: 100 },
            errorMultiplier: 1,
            noSpecialCharErrors: false,
            locale: 'en',
            perLetterDelay: { min: 40, max: 150 }
        };
        const ffOptions = this._fastForward ? this._fastForwardOptions : {};
        const currentQueueItemOptions = (_b = (_a = this._queue.item) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};
        return {
            ...defaultOptions,
            ...this._options,
            ...currentQueueItemOptions,
            ...ffOptions
        };
    }
    addKeyboard(locale, keyboard) {
        keyboards[locale] = keyboard;
    }
    async reset(clearTexts = false) {
        this._resultItems = [];
        this._fastForward = false;
        this.updateText();
        this._ffQueue.clear();
        if (clearTexts) {
            this._typeQueue.clear();
            while (this._endResultItems.pop()) {
                // do nothing
            }
        }
        await this._resetter.reset();
    }
    type(sentance, options) {
        this._typeQueue.add({
            type: 'sentance',
            text: sentance,
            options,
            className: options === null || options === void 0 ? void 0 : options.className
        });
        this.addLetterTo(sentance, this._endResultItems, options === null || options === void 0 ? void 0 : options.className);
        return this;
    }
    backspace(length, options) {
        this._typeQueue.add({
            type: 'backspace',
            length,
            options
        });
        this.deleteLetterFrom(this._endResultItems, length);
        return this;
    }
    wait(delay) {
        this._typeQueue.add({
            type: 'wait',
            delay
        });
        return this;
    }
    async run() {
        this._queue = this._typeQueue;
        this._typeQueue.resetIndices();
        this._resultItems = [];
        while (await this.doQueueAction()) {
            // do nothing
        }
    }
    fastForward() {
        if (this._fastForward) {
            return;
        }
        let matchingLetterCount = 0;
        while (true) {
            const currentTextAtIndex = this.getTextAtIndex(this._resultItems, matchingLetterCount);
            const endResultTextAtIndex = this.getTextAtIndex(this._endResultItems, matchingLetterCount);
            if (!currentTextAtIndex || !endResultTextAtIndex) {
                break;
            }
            if (currentTextAtIndex.letter === endResultTextAtIndex.letter &&
                currentTextAtIndex.className === endResultTextAtIndex.className) {
                matchingLetterCount++;
            }
            else {
                break;
            }
        }
        this._ffQueue.clear();
        this._queue = this._ffQueue;
        const currentTextWithoutClasses = this.getCurrentText(this._resultItems, false);
        const currentTextLength = currentTextWithoutClasses.length;
        const neededBackspaces = currentTextLength - matchingLetterCount;
        if (neededBackspaces) {
            this._ffQueue.add({
                type: 'backspace',
                length: neededBackspaces
            });
        }
        const resultTextLength = this.getCurrentText(this._endResultItems, false).length;
        for (let i = 0; i < resultTextLength - matchingLetterCount; i++) {
            const letter = this.getTextAtIndex(this._endResultItems, i + matchingLetterCount);
            this._ffQueue.add({
                type: 'sentance',
                text: letter.letter,
                options: undefined,
                className: letter.className
            });
        }
        this._fastForward = true;
        this._resetter.singleReset();
    }
    getTextAtIndex(resultItems, index) {
        let i = 0;
        let skipped = 0;
        while (resultItems[i]) {
            if (resultItems[i].text.length > index - skipped) {
                const letter = resultItems[i].text.substring(index - skipped, index - skipped + 1);
                const className = resultItems[i].className;
                return { letter, className };
            }
            else {
                skipped += resultItems[i].text.length;
                i++;
            }
        }
        return undefined;
    }
    async doQueueAction() {
        const currentQueueItem = this._queue.item;
        switch (currentQueueItem.type) {
            case 'sentance':
                return this.typeLetter();
            case 'backspace':
                return this.typeBackspace();
            case 'wait':
                return this.waitItem();
            default:
                throw new Error('Unknown queue item type');
        }
    }
    async typeLetter() {
        const queue = this._queue;
        const currentSentance = queue.item;
        const currentLetter = currentSentance.text[queue.detailIndex];
        await this.maybeDoError(currentSentance, 0, queue);
        if (queue === this._queue) {
            this.addLetter(currentLetter, currentSentance.className);
            this._lettersSinceLastError++;
            this.updateText();
            await wait(this.options.perLetterDelay, this._resetter);
        }
        return this.incrementQueue(queue, currentSentance.text.length);
    }
    async typeBackspace() {
        const queue = this._queue;
        const currentBackspaceItem = queue.item;
        if (currentBackspaceItem.length > 0) {
            this.deleteLetter();
            this.updateText();
            await wait(this.options.eraseDelay, this._resetter);
        }
        return this.incrementQueue(queue, currentBackspaceItem.length);
    }
    async waitItem() {
        const queue = this._queue;
        if (!this._fastForward) {
            const currentWaitItem = queue.item;
            await wait(currentWaitItem.delay, this._resetter);
        }
        return this.incrementQueue(queue);
    }
    incrementQueue(queue, maxDetailIndex) {
        if (queue === this._queue) {
            return queue.increment(maxDetailIndex);
        }
        else {
            return this.doQueueAction();
        }
    }
    async shouldError(currentWrongLettersCount, intendedChar, wasFF, nearbyChar) {
        const errorProbability = this.calculateErrorProbability(currentWrongLettersCount);
        let willError = true;
        if (Math.random() > errorProbability) {
            willError = false;
        }
        if (!intendedChar) {
            willError = false;
        }
        if (this.options.noSpecialCharErrors && isSpecialChar(intendedChar)) {
            willError = false;
        }
        if (!nearbyChar) {
            willError = false;
        }
        if (!willError || !nearbyChar) {
            if (currentWrongLettersCount > 0) {
                if (!this._fastForward || wasFF) {
                    await wait(this.options.errorDelay, this._resetter);
                }
            }
        }
        return willError;
    }
    async maybeDoError(currentSentance, currentWrongLettersCount, queue) {
        const wasFF = this._fastForward;
        const intendedChar = currentSentance.text[queue.detailIndex + currentWrongLettersCount];
        const nearbyChar = this._randomChars.getRandomCharCloseToChar(intendedChar, this.options.locale);
        const shouldError = await this.shouldError(currentWrongLettersCount, intendedChar, wasFF, nearbyChar);
        if (!shouldError || !nearbyChar) {
            return;
        }
        this._lettersSinceLastError = 0;
        this.addLetter(nearbyChar, currentSentance.className);
        this.updateText();
        await wait(this.options.perLetterDelay, this._resetter);
        if (!this._fastForward || wasFF) {
            await this.maybeDoError(currentSentance, currentWrongLettersCount + 1, queue);
        }
        if (!this._fastForward || wasFF) {
            this.deleteLetter();
            this.updateText();
        }
        if (!this._fastForward || wasFF) {
            await wait(this.options.eraseDelay, this._resetter);
        }
    }
    calculateErrorProbability(currentWrongLettersCount) {
        let errorProbability = 0;
        // The more correct letters we typed, the more likely we are to make an error
        errorProbability += (1 / 1000) * Math.pow(this._lettersSinceLastError, 2);
        // If we just made an error, the more likely we are to make another one
        if (currentWrongLettersCount === 1) {
            errorProbability += 0.4;
        }
        else if (currentWrongLettersCount === 2) {
            errorProbability += 0.2;
        }
        // Adjust based on the configured modifier
        return errorProbability * this.options.errorMultiplier;
    }
    addLetter(letter, className) {
        this.addLetterTo(letter, this._resultItems, className);
    }
    addLetterTo(letter, result, className) {
        const lastResultItem = result[result.length - 1];
        if (lastResultItem && lastResultItem.className === className) {
            lastResultItem.text += letter;
        }
        else {
            result.push({
                text: letter,
                className
            });
        }
    }
    deleteLetter() {
        this.deleteLetterFrom(this._resultItems);
    }
    deleteLetterFrom(result, length = 1) {
        let needsAnotherDelete = false;
        do {
            let deleteAmountForThisItem = length;
            const lastResultItem = result[result.length - 1];
            const maxDeletableAmount = lastResultItem.text.length;
            if (maxDeletableAmount < length) {
                deleteAmountForThisItem = maxDeletableAmount;
                length -= maxDeletableAmount;
                needsAnotherDelete = true;
            }
            if (lastResultItem) {
                lastResultItem.text = lastResultItem.text.slice(0, -deleteAmountForThisItem);
                if (!lastResultItem.text) {
                    result.pop();
                }
            }
            else {
                if (this._resetter.isReset) {
                    // might happen due to still running code during reset
                    return;
                }
                throw new Error('Cannot delete letter from empty text');
            }
        } while (needsAnotherDelete);
    }
    updateText() {
        if (this._resetter.isReset) {
            return;
        }
        const text = this.getCurrentText(this._resultItems);
        this.options.callback(text);
    }
    getCurrentText(result, includeClasses = true) {
        return result
            .map(item => {
            if (item.className && includeClasses) {
                return `<span class="${item.className}">${item.text}</span>`;
            }
            else {
                return item.text;
            }
        })
            .join('');
    }
}
//# sourceMappingURL=typed.js.map